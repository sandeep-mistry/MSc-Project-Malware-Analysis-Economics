# Grebber 
# This code extracts the row which includes __stdcall or FUNCTION in the corresponding rows
# We mimic the grep function of linux

import subprocess
import os
from multiprocessing import Process
from common import *
import Reader as r
from progressbar import Percentage, Bar, ProgressBar, ETA
import sys

# Split the data into n approximately equal groups
def chunks(data, n):
    k, m = divmod(len(data), n)
    return list(data[i*k + min(i, m):(i + 1)*k + min(i+1, m)] for i in range(n))
    
# Read code, look for pattern, write to file and save
def grep(inputFn, outputFn, pattern):
    file = r.readAsmCode(inputFn)
    out = open(outputFn, "w")
    for row in file:
        if pattern in row:
            out.write(row)
            out.write("\n")
    out.close()     
    

# Each worker initiates function by themselves    
def worker(chunk, output_dir_call, output_dir_function):
    # Sweet progressbar 
    widgets = ['Worker {}: '.format(chunk[0]), ' ', Percentage(), ' ', Bar(), ' ', ETA()]
    pbar = ProgressBar(widgets=widgets, maxval=len(chunk[1])).start()
    for idx, item in enumerate(chunk[1]):
        fn = item.split(os.sep)[-1].split(".")[0]
        
        # greb __stdcall
        txt_path_call = os.path.join(output_dir_call, fn)
        grep(item, txt_path_call, "__stdcall")
        
        # greb FUNCTION
        txt_path_function = os.path.join(output_dir_function, fn)
        grep(item, txt_path_function, "FUNCTION")
        
        # Update progressbar
        pbar.update(idx+1)
    pbar.finish()

        
if __name__ == "__main__":
    print("Grebber started!")
    
    # Generate full paths depending on dataset type
    # Is it a training or testing dataset?
    if sys.argv[1] == "train":
        main_path = os.path.join(root_path, "train")
        split_data = chunks(train_asm, numWorkers)
    else:
        main_path = os.path.join(root_path, "test")
        split_data = chunks(test_asm, numWorkers)
    
    # __stdcall
    output_dir_call = os.path.join(main_path, os.path.join("data", "stdcall"))
    
    # FUNCTION
    output_dir_function = os.path.join(main_path, os.path.join("data", "function"))
    
    # Create directories   
    clearPath(output_dir_call)
    clearPath(output_dir_function)
    
    # Power of multithreading starts!!
    jobs = []
    for item in enumerate(split_data):
        p = Process(target=worker, args=(item,output_dir_call,output_dir_function))
        jobs.append(p)
        p.start()
        
    for j in jobs:
        j.join()
        
    print("Grebber completed!")