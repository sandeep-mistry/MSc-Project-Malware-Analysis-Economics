import pefile

SECTION_VIRTUAL_SIZE_HEADER = ['.idata', '.rdata', '.data', '.rsrc', '.reloc']
desired_sections_entropy_virtual_size = ['.idata', '.rdata', '.data', '.rsrc', '.reloc']
ALERTS_HEADER = ["LoadLibrary",
        "GetProcAddress",
        "MessageBox",
        "ShellExecute",
        "IsDebuggerPresent",
        "VirtualAlloc",
        "CreateThread",
        "CreateProcess",
        "OpenProcess*",
        "RaiseException",
        "CreateEvent",
        "GetSystemInfo",
        "GetComputerName",
        "SetWindowsHook",
        "WriteProcessMemory",
        "GetTickCount",
        "Sleep",
        "GetDiskFreeSpace",
        "SetThreadContext",
        "CreateRemoteThread",
         "GetVersion",
         "GetProcessHeap",
         "GetUserName",
         "ExitProcess",
         "CorExeMain",
         "WaitForSingleObject",
         "GetStartupInfo",
         "GetKeyboard",
        "SetUnhandledExceptionFilter",
        "HttpSendRequest",
        "HttpQueryInfo"
                 ]


IMPORTED_API_COUNT = ["KERNEL", "USER", "ADVAPI", "SHELL", "COMCTL", "CRYPT", "MSVCR", "GDI", "SHLWAPI", "WS", "WININET", "WINHTTP"]
IMPORTED_LIBRARIES_COUNT = ["Imported libraries count"]


def virtual_size_raw_size_ratio(pe):
    verdicts = {}
    present_verdicts = []
    for section in pe.sections:
        sectionname = ''.join(filter(lambda c: c != '\0', str(section.Name.decode('utf-8'))))
        raw_size = section.SizeOfRawData
        virtual_size = section.Misc_VirtualSize
        if 0.5 * virtual_size > raw_size:
            verdict = "1"
        else:
            verdict = "0"
        verdicts.update({sectionname: verdict})

    for item in SECTION_VIRTUAL_SIZE_HEADER:
        for key, value in verdicts.items():
            if key == item:
                present_verdicts.append(value)
        if item not in verdicts:
            present_verdicts.append(None)
        else:
            continue

    return present_verdicts


def check_entropy(pe):
    entropies = {}
    PRESENT_ENTROPIES_data = []
    for section in pe.sections:
        sectionname = ''.join(filter(lambda c: c != '\0', str(section.Name.decode('utf-8'))))
        get_entropy = section.get_entropy()
        entropies.update({sectionname: get_entropy})

    for item in desired_sections_entropy_virtual_size :
        for key, value in entropies.items():
            if key == item:
                PRESENT_ENTROPIES_data.append(value)
        if item not in entropies:
            PRESENT_ENTROPIES_data.append(None)
        else:
            continue
    return PRESENT_ENTROPIES_data


def check_imports(pe):
    ret = []
    ret2 = []
    present_alerts = []
    present_alerts_frequency = []
    if not hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
        return ret
    for lib in pe.DIRECTORY_ENTRY_IMPORT:
        for imp in lib.imports:
            ret.append(imp.name)
    for n in ret:
        if n:
            n = n.decode('utf-8')
            if any(map(n.startswith, ALERTS_HEADER)):
                for a in ALERTS_HEADER:
                    if n.startswith(a):
                        # ret2.append(n)
                        ret2.append(n)

    for alert in ALERTS_HEADER:
        for item in ret2:
            if item.startswith(alert):
                present_alerts.append(alert)

    for alert in ALERTS_HEADER:
        if alert in present_alerts:
            present_alerts_frequency.append(present_alerts.count(alert))
        elif alert not in present_alerts:
            present_alerts_frequency.append(0)

    return present_alerts_frequency


def get_imported_api_counts(pe):
    IMPORTED_API_COUNT_data = []

    for item in IMPORTED_API_COUNT:
        item_count = 0
        for entry in pe.DIRECTORY_ENTRY_IMPORT:
            entry_dll = entry.dll.decode('utf-8')
            if entry_dll.startswith(item):
                item_count += len(entry.imports)
            else:
                continue
        IMPORTED_API_COUNT_data.append(item_count)
    return IMPORTED_API_COUNT_data


def get_imported_libraries_count(pe):
    count = 0
    for entry in pe.DIRECTORY_ENTRY_IMPORT:
        while True:
            count += 1
            break
    return [count]
